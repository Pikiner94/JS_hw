// Петриченко
// Прототипное программирование - Объектно-ориентированный-подход

// Мы представляем любую вещи как Обьект со своими методами

// Объект - это сущность, которую делают по прототипу (Как автомобиль, который выпушен )
// Instance -

// В JS мы все пишем в процедурном стиле

// Класс - это шаблон, по которому делаю объекты(это его чертеж)

// Пример с автомобилем

// Interface - это метод, который записан в объекте (функции, которые позволяют взаимодействовать с Интерфейсом)

// Основы или 3 кита

// Наследование - наследование свойст и методов

// Абстракция - отбросить все элементы, чтобы увидеть главную часть и позволяет работать с ним не думаю об устройсте этого объекта

// Есть уровни обстракции чем ниже уровень абстракции, тем на большие части объект

// Инкапсуляция - механизм скрытия информации

// Полиморфизм - одинаковая способность, но разный метод реализации

// ПРОТОТИП - это объект на который ссылается другой объект

// Объект может наследовать свойства из прототипа

// Протипное наследование в JS

// Для каждого типа данных есть встроенные конструкторы

// Можно создавать массив через
// let arr = new Array(1, 2, 4, 6);
// console.log(arr);

// instanceof - позволяет делать проверку на экземля

// Оператор new -
// 1. Создает пустой объект
// 2. пустой объект связывает с функцией

// function baba(price, age, discount) {
//   (this.price = price),
//     (this.name = name),
//     (this.discount = discount),
//     (this.getDiscount = function () {
//       return this.price - (this.price - (this.price - this.discount));
//     });
// }
// let b = new baba(400, 21, 45);

// console.log(b.getDiscount());

// Можно в функцию добавить свой метод

// Методы, которыми будут пользоватся инстенсы мы выносим в прототип

///////////////////////////

// Наследование

// Object.create() - Создает прототип с прототипом и свойствами

// Можно скопировать все все прототипы записав такой синтаксис:  User(тут пишем объект).prototype(Скопировать) =

// Закончил на 2 часах 40 минутах

// ES6

// Class может иметь только один конструктор

// class Product {
//     constructor(brand, price, discount)
// }

// getPriceWithDiscount() {

// }

// Getters // Setters

// get brand ()

// set brand () {
//     this brand = new
// }

// прототип - это объекта, который присудствует у родительских сущностей

// Можно расширить родительский прототип и добавить в него новый метод, который будет использоватся в объекте

// let person = {
//   name: 'Vova',
//   hobby: 'Mafia',

//   sayHello() {
//     console.log('hello');
//   },
// };
// let lena = Object.create(person);

// console.log(lena.sayHello());

// lena.name = 'Elena';

// Static÷

// Нужен, чтобы хранить что-то на классе

// class calc {
//   constructor() {}

//   static get PI() {
//     return 3.14;
//   }

//   static Add  (a,b) {
//       return (a + b)
//   }

//   static multi (a*b) {
//       return (a*b)
//   }
// }

// Множественное наследование не поддерживается в js.
// const john = Object.create(solder) - команда читается, как создается прототип jonh, который создает свой объект.

// Функции конструкторы

// Функция - это объект в который можно положить любой метод и функцию

// class Rectangle {
//     constructor(height, width) {
//         this.height = height;
//         this.width = width;

//         calcArea() {
//             return this.height*this.width
//         }
//     }
// }

// Конструктор super вызывает те же пропсы, что были и  родителя, но она должна быть на первом месте в конструкторе
